<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Build on NEAR: Our first smart contract (part 1.1) | Till's blog</title>
<meta name=keywords content="Build on NEAR,Rust,NEAR protocol,Smart contracts">
<meta name=description content="In the kick-off post, we explored NEAR accounts and the CLI as prerequisites for deploying smart contracts on top of the NEAR protocol. This posts goes over the facets of writing smart contracts in general and conclude with the foundations for the remainder of the series.
The actual contract will be a simple &ldquo;Buy me a coffee&rdquo; contract, so basically a donation of NEAR to an account that the contract has been deployed with.">
<meta name=author content="Till">
<link rel=canonical href=http://tifrel.github.io/posts/build-on-near-1.1/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://tifrel.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=http://tifrel.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://tifrel.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=http://tifrel.github.io/apple-touch-icon.png>
<link rel=mask-icon href=http://tifrel.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-218706363-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Build on NEAR: Our first smart contract (part 1.1)">
<meta property="og:description" content="In the kick-off post, we explored NEAR accounts and the CLI as prerequisites for deploying smart contracts on top of the NEAR protocol. This posts goes over the facets of writing smart contracts in general and conclude with the foundations for the remainder of the series.
The actual contract will be a simple &ldquo;Buy me a coffee&rdquo; contract, so basically a donation of NEAR to an account that the contract has been deployed with.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://tifrel.github.io/posts/build-on-near-1.1/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-01-30T00:00:00+00:00">
<meta property="article:modified_time" content="2022-01-30T00:00:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Build on NEAR: Our first smart contract (part 1.1)">
<meta name=twitter:description content="In the kick-off post, we explored NEAR accounts and the CLI as prerequisites for deploying smart contracts on top of the NEAR protocol. This posts goes over the facets of writing smart contracts in general and conclude with the foundations for the remainder of the series.
The actual contract will be a simple &ldquo;Buy me a coffee&rdquo; contract, so basically a donation of NEAR to an account that the contract has been deployed with.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://tifrel.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Build on NEAR: Our first smart contract (part 1.1)","item":"http://tifrel.github.io/posts/build-on-near-1.1/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Build on NEAR: Our first smart contract (part 1.1)","name":"Build on NEAR: Our first smart contract (part 1.1)","description":"In the kick-off post, we explored NEAR accounts and the CLI as prerequisites for deploying smart contracts on top of the NEAR protocol. This posts goes over the facets of writing smart contracts in general and conclude with the foundations for the remainder of the series.\nThe actual contract will be a simple \u0026ldquo;Buy me a coffee\u0026rdquo; contract, so basically a donation of NEAR to an account that the contract has been deployed with.","keywords":["Build on NEAR","Rust","NEAR protocol","Smart contracts"],"articleBody":"In the kick-off post, we explored NEAR accounts and the CLI as prerequisites for deploying smart contracts on top of the NEAR protocol. This posts goes over the facets of writing smart contracts in general and conclude with the foundations for the remainder of the series.\nThe actual contract will be a simple “Buy me a coffee” contract, so basically a donation of NEAR to an account that the contract has been deployed with. Additionally, we will keep track of donations.\nA plain rust struct, compiled to WebAssembly Picking up our average Rust dev, with start with a new library project:\ncargo init --lib First of all let’s have a struct that holds some state and define a method that changes the state and returns some value. This is our src/lib.rs including logic and some tests:\n#[derive(Default)] pub struct Contract { last_number: u32, } impl Contract { pub fn execute(\u0026mut self, x: u32) - u32 { let r = self.last_number + x; self.last_number = x; r } } #[cfg(test)] mod tests { use super::*; #[test] fn contract_works() { let mut contract = Contract::default(); assert_eq!(contract.execute(4), 4); assert_eq!(contract.execute(2), 6); } } Don’t worry about the usefulness, we will replace this soon with something more elaborate, but we need to acquainted with the requirements and specifics for deploying that code on NEAR. In Rustland, your smart contract is nothing more than some data, you could also call it storage or state, and some associated logic within impl blocks.\nThe most obvious part is compilation to WebAssembly. If you haven’t done so already, you should install the WebAssembly compilation target for Rust:\nrustup target add wasm32-unknown-unknown By default, cargo will build for the machine architecture you’re compiling on. However, we want to target WebAssembly, and will use this .cargo/config.toml:\n[alias] emit = \"build --release --target wasm32-unknown-unknown\" [target.wasm32-unknown-unknown] rustflags = [\"-C\", \"link-arg=-s\"] [profile.release] codegen-units = 1 # generate a single blob of machine/Wasm instructions opt-level = \"z\" # optimize for code size lto = true # compile at link time debug = false # no debug symbols/checks panic = \"abort\" # usually unwind, but that's extra overhead overflow-checks = true # enable safety checks for arithmetic operations Although not necessary lecture, let’s go over these adjustments in a bit more detail:\n alias.emit: Eases compilation, as we either have test builds, run via cargo test, or release builds to Wasm, which are now handily available using cargo emit. target.wasm32-unknown-unknown.rustflags: Additional flags passed to rustc when compiling to Wasm. We instruct rustc to pass the -s flag on to the linker, which means the linker should optimize for code size over performance. Some flag-passing inception going on. profile.release: Modify the optimization options for the release build  codegen-units = 1: We want a single unit/blob of machine code from our crate, which is then linked against the dependency crates. opt-level = \"z\": Aggressively optimize for code size. Disables loop vectorization. lto: link-time-optimizations debug: include debug information/checks (e.g. arithmetic overflows) panic = \"abort\": Rust usually unwinds the call stack on a panic. Unwinding the stack is extra logic that requires extra space. Instead, we simply drop everything we’re doing an return. overflow-checks: Check for arithmetic overflows. This does cost extra computation and space, but prevents vulnerabilities. Image you issued a burnable token, someone burns more than he has and voíla, that someone now has more tokens than all other token holders combined.    As you can see, anything is optimized aggressively for storage. You will find this a recurring theme, as on-chain storage is a scarce resource, and thus protected by an economic incentive called storage staking. Your contract always needs some immovable NEAR attached to “rent” (indirectly, by lowering total supply) the storage it uses on the chain. If you decide to reduce your contracts storage requirements or to take it offline, you can recover these funds, giving you an incentive not to occupy chain-storage lightheadedly.\nAs we seperated all our “What kind of machine code do we want?” options into .cargo/config.toml, our Cargo.toml can stay clean:\n[package] name = \"near-buy-me-a-coffee\" version = \"0.1.0\" edition = \"2021\" [lib] crate-type = [\"cdylib\"] [dependencies] near-sdk = \"3.1.0\" Again, let’s look at the relevant sections:\n lib.crate-type = \"cdylib\": That’s just a general requirement for WebAssembly and it being naturally loaded on-demand. dependencies.near-sdk: All we will need to do all things NEAR, e.g. transactions, cross-contract calls, or blockchain-specific testing  Once you’ve got this set up, you issue a cargo emit. You will find your Wasm blob at target/wasm32-unknown-unknown/release/near_buy_me_a_coffee.wasm. Looking at it with an editor should give you a bunch of funny symbols. It’s some kind of machine code after all, so if it’s not human-readable, that’s a good sign.\nAdding NEAR Now, let’s turn this struct into a smart contract. Again, we take a look at our src/lib.rs, and then talk about the changes we applied:\n// these traits allow us to convert the struct into the borsh binary format, // which is used by NEAR and thus required for smart contracts on the protocol use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize}; // this macro wraps our with everything necessary to deploy it to the chain. use near_sdk::near_bindgen; #[near_bindgen] #[derive(Default, BorshDeserialize, BorshSerialize)] pub struct Contract { last_number: u32, } #[near_bindgen] impl Contract { pub fn execute(\u0026mut self, x: u32) - u32 { let r = self.last_number + x; self.last_number = x; r } } #[cfg(test)] mod tests { use super::*; // needed for creating the blockchain context, see macro definition below  use near_sdk::test_utils::VMContextBuilder; use near_sdk::{testing_env, MockedBlockchain}; use std::convert::TryInto; // part of writing unit tests is setting up a mock context  macro_rules! init_context { ($account:expr) = { // first convert the `\u0026str` to a `near_sdk::json_types::ValidAccountId`  let account = $account.to_string().try_into().unwrap(); // build the `near_sdk::VMContext`  let context = VMContextBuilder::new() .predecessor_account_id(account) .build(); // this actually initializes the context  testing_env!(context); }; } #[test] fn contract_works() { // initialize the testing context  init_context!(\"tifrel.testnet\"); // the actual test stays as it was in the plain-rust case  let mut contract = Contract::default(); assert_eq!(contract.execute(4), 4); assert_eq!(contract.execute(2), 6); } }  Borsh is a binary serialization format that allows to translate between something easily comprehensible, e.g. a struct, an enum, or a plain i32 and something that’s efficient to store and transmit, aka some raw bytes. We need it, because that’s how we store data on the NEAR blockchain. near_sdk::near_bindgen automagically wraps your contract and equips it with all it needs to a) compile to Wasm and b) interact with other parts of the NEAR protocol, e.g. other smart contracts or NEAR acconts. All parts of your smart contract (struct { ... }, impl blocks) need to be wrapped.  If all you wanted to do is deploying some logic on-chain, that’s already all you need. But we want to deploy something high-quality. We want to make use of practices like TDD, so we take the time to understand testing for the blockchain-world as well: Before contract method calls, we need to initialize a context. The context holds information like the calling account of a contracts methods, NEAR tokens attached to the call, or block information. A context will be used for all subsequent function calls, until it is set again.\nWriting tests for our actual contract Now that we’ve gained an understanding of how to write smart contracts on NEAR, let’s start by writing the test for our actual “Buy Me A Coffee Contract”:\n#[cfg(test)] mod tests { use super::*; use near_sdk::test_utils::VMContextBuilder; use near_sdk::{testing_env, MockedBlockchain}; use std::convert::TryInto; // Handy if you don't wish to deal with yoctoNEAR all the time  const ONE_NEAR: near_sdk::Balance = 1_000_000_000_000_000_000_000_000; macro_rules! init_context { ($account:expr) = { let account = $account.to_string().try_into().unwrap(); let context = VMContextBuilder::new() .predecessor_account_id(account) .build(); testing_env!(context); }; // Another macro pattern, as we now need to send some NEAR with our contract  // calls  ($account:expr, $deposit:expr) = { let account = $account.to_string().try_into().unwrap(); let context = VMContextBuilder::new() .predecessor_account_id(account) .attached_deposit($deposit) .build(); testing_env!(context); }; } #[test] fn contract_works() { init_context!(\"tifrel.testnet\"); let mut contract = BuyMeACoffee::initialize(\"tifrel.testnet\".into()); assert_eq!(contract.top_coffee_buyer(), None); // our next contract call will be by \"lovely-person.testnet\", with one NEAR  // attached to the call  init_context!(\"lovely-person.testnet\", 1 * ONE_NEAR); contract.buy_coffee(); // We can see the donation if we query the contract by `AccountId`  assert_eq!( contract.coffee_near_from(\"lovely-person.testnet\".into()), 1 * ONE_NEAR ); // Since it's the first donation, it has taken the leaderboard  assert_eq!( contract.top_coffee_buyer(), Some((\"lovely-person.testnet\".into(), 1 * ONE_NEAR)) ); // Let's do it again  init_context!(\"another-lovely-person.testnet\", 2 * ONE_NEAR); contract.buy_coffee(); assert_eq!( contract.coffee_near_from(\"another-lovely-person.testnet\".into()), 2 * ONE_NEAR ); assert_eq!( contract.top_coffee_buyer(), Some((\"another-lovely-person.testnet\".into(), 2 * ONE_NEAR)) ); } } This test ensures that\n The contract initializes NEAR accounts can send NEAR tokens to it We can query the contract for specific accounts and get their total NEAR donation The account that donated the most can be queried. Think of it as a single-slot hall of fame.  What’s the best part? Now we can issue cargo test, and actually verify that what we’re building is doing what we want it to. Remember that cargo run on a library doesn’t do anything, and cargo build is shaky ground when you want to attach (potentially valuable) digital assets to whatever you’re building.\nWrap-up We have gotten familiar with the basics of smart contracts in Wasm environemnts, and learned how to set up tests for NEAR smart contracts. The next post we will TDD ourselves to deployment.\n","wordCount":"1531","inLanguage":"en","datePublished":"2022-01-30T00:00:00Z","dateModified":"2022-01-30T00:00:00Z","author":{"@type":"Person","name":"Till"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://tifrel.github.io/posts/build-on-near-1.1/"},"publisher":{"@type":"Organization","name":"Till's blog","logo":{"@type":"ImageObject","url":"http://tifrel.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://tifrel.github.io/ accesskey=h title="Till's blog (Alt + H)">Till's blog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=http://tifrel.github.io/tags title=Tags>
<span>Tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://tifrel.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://tifrel.github.io/posts/>Posts</a></div>
<h1 class=post-title>
Build on NEAR: Our first smart contract (part 1.1)
</h1>
<div class=post-meta><span title="2022-01-30 00:00:00 +0000 WET">2022-01-30</span>&nbsp;·&nbsp;Till
</div>
</header>
<div class=post-content><p>In the <a href=../build-on-near-0>kick-off post</a>, we explored NEAR accounts and the
CLI as prerequisites for deploying smart contracts on top of the NEAR protocol.
This posts goes over the facets of writing smart contracts in general and
conclude with the foundations for the remainder of the series.</p>
<p>The actual contract will be a simple &ldquo;Buy me a coffee&rdquo; contract, so basically a
donation of NEAR to an account that the contract has been deployed with.
Additionally, we will keep track of donations.</p>
<h2 id=a-plain-rust-struct-compiled-to-webassembly>A plain rust struct, compiled to WebAssembly<a hidden class=anchor aria-hidden=true href=#a-plain-rust-struct-compiled-to-webassembly>#</a></h2>
<p>Picking up our average Rust dev, with start with a new library project:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>cargo init --lib
</code></pre></div><p>First of all let&rsquo;s have a struct that holds some state and define a method that
changes the state and returns some value. This is our <code>src/lib.rs</code> including
logic and some tests:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=color:#75715e>#[derive(Default)]</span>
<span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Contract</span> {
  last_number: <span style=color:#66d9ef>u32</span>,
}

<span style=color:#66d9ef>impl</span> Contract {
  <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>execute</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, x: <span style=color:#66d9ef>u32</span>) -&gt; <span style=color:#66d9ef>u32</span> {
    <span style=color:#66d9ef>let</span> r <span style=color:#f92672>=</span> self.last_number <span style=color:#f92672>+</span> x;
    self.last_number <span style=color:#f92672>=</span> x;
    r
  }
}

<span style=color:#75715e>#[cfg(test)]</span>
<span style=color:#66d9ef>mod</span> tests {
  <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>super</span>::<span style=color:#f92672>*</span>;

  <span style=color:#75715e>#[test]</span>
  <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>contract_works</span>() {
    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> contract <span style=color:#f92672>=</span> Contract::default();
    assert_eq!(contract.execute(<span style=color:#ae81ff>4</span>), <span style=color:#ae81ff>4</span>);
    assert_eq!(contract.execute(<span style=color:#ae81ff>2</span>), <span style=color:#ae81ff>6</span>);
  }
}
</code></pre></div><p>Don&rsquo;t worry about the usefulness, we will replace this soon with something more
elaborate, but we need to acquainted with the requirements and specifics for
deploying that code on NEAR. In Rustland, your smart contract is nothing more
than some data, you could also call it storage or state, and some associated
logic within <code>impl</code> blocks.</p>
<p>The most obvious part is compilation to WebAssembly. If you haven&rsquo;t done so
already, you should install the WebAssembly compilation target for Rust:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>rustup target add wasm32-unknown-unknown
</code></pre></div><p>By default, <code>cargo</code> will build for the machine architecture you&rsquo;re compiling on.
However, we want to target WebAssembly, and will use this <code>.cargo/config.toml</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml>[<span style=color:#a6e22e>alias</span>]
<span style=color:#a6e22e>emit</span> = <span style=color:#e6db74>&#34;build --release --target wasm32-unknown-unknown&#34;</span>

[<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>wasm32-unknown-unknown</span>]
<span style=color:#a6e22e>rustflags</span> = [<span style=color:#e6db74>&#34;-C&#34;</span>, <span style=color:#e6db74>&#34;link-arg=-s&#34;</span>]

[<span style=color:#a6e22e>profile</span>.<span style=color:#a6e22e>release</span>]
<span style=color:#a6e22e>codegen-units</span> = <span style=color:#ae81ff>1</span>      <span style=color:#75715e># generate a single blob of machine/Wasm instructions</span>
<span style=color:#a6e22e>opt-level</span> = <span style=color:#e6db74>&#34;z&#34;</span>        <span style=color:#75715e># optimize for code size</span>
<span style=color:#a6e22e>lto</span> = <span style=color:#66d9ef>true</span>             <span style=color:#75715e># compile at link time</span>
<span style=color:#a6e22e>debug</span> = <span style=color:#66d9ef>false</span>          <span style=color:#75715e># no debug symbols/checks</span>
<span style=color:#a6e22e>panic</span> = <span style=color:#e6db74>&#34;abort&#34;</span>        <span style=color:#75715e># usually unwind, but that&#39;s extra overhead</span>
<span style=color:#a6e22e>overflow-checks</span> = <span style=color:#66d9ef>true</span> <span style=color:#75715e># enable safety checks for arithmetic operations</span>
</code></pre></div><p>Although not necessary lecture, let&rsquo;s go over these adjustments in a bit more
detail:</p>
<ul>
<li><code>alias.emit</code>: Eases compilation, as we either have test builds, run via
<code>cargo test</code>, or release builds to Wasm, which are now handily available using
<code>cargo emit</code>.</li>
<li><code>target.wasm32-unknown-unknown.rustflags</code>: Additional flags passed to <code>rustc</code>
when compiling to Wasm. We instruct <code>rustc</code> to pass the <code>-s</code> flag on to the
linker, which means the linker should optimize for code size over performance.
Some flag-passing inception going on.</li>
<li><code>profile.release</code>: Modify the optimization options for the release build
<ul>
<li><code>codegen-units = 1</code>: We want a single unit/blob of machine code from our
crate, which is then linked against the dependency crates.</li>
<li><code>opt-level = "z"</code>: Aggressively optimize for code size. Disables loop
vectorization.</li>
<li><code>lto</code>: <strong>l</strong>ink-<strong>t</strong>ime-<strong>o</strong>ptimizations</li>
<li><code>debug</code>: include debug information/checks (e.g. arithmetic overflows)</li>
<li><code>panic = "abort"</code>: Rust usually unwinds the call stack on a panic. Unwinding
the stack is extra logic that requires extra space. Instead, we simply drop
everything we&rsquo;re doing an return.</li>
<li><code>overflow-checks</code>: Check for arithmetic overflows. This does cost extra
computation and space, but prevents vulnerabilities. Image you issued a
burnable token, someone burns more than he has and voíla, that someone now
has more tokens than all other token holders combined.</li>
</ul>
</li>
</ul>
<p>As you can see, anything is optimized aggressively for storage. You will find
this a recurring theme, as on-chain storage is a scarce resource, and thus
protected by an economic incentive called
<a href=https://docs.near.org/docs/concepts/storage-staking>storage staking</a>. Your
contract always needs some immovable NEAR attached to &ldquo;rent&rdquo; (indirectly, by
lowering total supply) the storage it uses on the chain. If you decide to reduce
your contracts storage requirements or to take it offline, you can recover these
funds, giving you an incentive not to occupy chain-storage lightheadedly.</p>
<p>As we seperated all our &ldquo;What kind of machine code do we want?&rdquo; options into
<code>.cargo/config.toml</code>, our <code>Cargo.toml</code> can stay clean:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml>[<span style=color:#a6e22e>package</span>]
<span style=color:#a6e22e>name</span> = <span style=color:#e6db74>&#34;near-buy-me-a-coffee&#34;</span>
<span style=color:#a6e22e>version</span> = <span style=color:#e6db74>&#34;0.1.0&#34;</span>
<span style=color:#a6e22e>edition</span> = <span style=color:#e6db74>&#34;2021&#34;</span>

[<span style=color:#a6e22e>lib</span>]
<span style=color:#a6e22e>crate-type</span> = [<span style=color:#e6db74>&#34;cdylib&#34;</span>]

[<span style=color:#a6e22e>dependencies</span>]
<span style=color:#a6e22e>near-sdk</span> = <span style=color:#e6db74>&#34;3.1.0&#34;</span>
</code></pre></div><p>Again, let&rsquo;s look at the relevant sections:</p>
<ul>
<li><code>lib.crate-type = "cdylib"</code>: That&rsquo;s just a
<a href=https://stackoverflow.com/questions/56227766/why-must-a-wasm-library-in-rust-set-the-crate-type-to-cdylib>general requirement for WebAssembly</a>
and it being naturally loaded on-demand.</li>
<li><code>dependencies.near-sdk</code>: All we will need to do all things NEAR, e.g.
transactions, cross-contract calls, or blockchain-specific testing</li>
</ul>
<p>Once you&rsquo;ve got this set up, you issue a <code>cargo emit</code>. You will find your Wasm
blob at <code>target/wasm32-unknown-unknown/release/near_buy_me_a_coffee.wasm</code>.
Looking at it with an editor should give you a bunch of funny symbols. It&rsquo;s some
kind of machine code after all, so if it&rsquo;s not human-readable, that&rsquo;s a good
sign.</p>
<h2 id=adding-near>Adding NEAR<a hidden class=anchor aria-hidden=true href=#adding-near>#</a></h2>
<p>Now, let&rsquo;s turn this struct into a smart contract. Again, we take a look at our
<code>src/lib.rs</code>, and then talk about the changes we applied:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=color:#75715e>// these traits allow us to convert the struct into the borsh binary format,
</span><span style=color:#75715e>// which is used by NEAR and thus required for smart contracts on the protocol
</span><span style=color:#75715e></span><span style=color:#66d9ef>use</span> near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
<span style=color:#75715e>// this macro wraps our with everything necessary to deploy it to the chain.
</span><span style=color:#75715e></span><span style=color:#66d9ef>use</span> near_sdk::near_bindgen;

<span style=color:#75715e>#[near_bindgen]</span>
<span style=color:#75715e>#[derive(Default, BorshDeserialize, BorshSerialize)]</span>
<span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Contract</span> {
  last_number: <span style=color:#66d9ef>u32</span>,
}

<span style=color:#75715e>#[near_bindgen]</span>
<span style=color:#66d9ef>impl</span> Contract {
  <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>execute</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, x: <span style=color:#66d9ef>u32</span>) -&gt; <span style=color:#66d9ef>u32</span> {
    <span style=color:#66d9ef>let</span> r <span style=color:#f92672>=</span> self.last_number <span style=color:#f92672>+</span> x;
    self.last_number <span style=color:#f92672>=</span> x;
    r
  }
}

<span style=color:#75715e>#[cfg(test)]</span>
<span style=color:#66d9ef>mod</span> tests {
  <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>super</span>::<span style=color:#f92672>*</span>;
  <span style=color:#75715e>// needed for creating the blockchain context, see macro definition below
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>use</span> near_sdk::test_utils::VMContextBuilder;
  <span style=color:#66d9ef>use</span> near_sdk::{testing_env, MockedBlockchain};
  <span style=color:#66d9ef>use</span> std::convert::TryInto;

  <span style=color:#75715e>// part of writing unit tests is setting up a mock context
</span><span style=color:#75715e></span>  macro_rules! init_context {
    (<span style=color:#75715e>$account</span>:<span style=color:#a6e22e>expr</span>) <span style=color:#f92672>=&gt;</span> {
      <span style=color:#75715e>// first convert the `&amp;str` to a `near_sdk::json_types::ValidAccountId`
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>let</span> account <span style=color:#f92672>=</span> <span style=color:#75715e>$account</span>.to_string().try_into().unwrap();

      <span style=color:#75715e>// build the `near_sdk::VMContext`
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>let</span> context <span style=color:#f92672>=</span> VMContextBuilder::new()
        .predecessor_account_id(account)
        .build();

      <span style=color:#75715e>// this actually initializes the context
</span><span style=color:#75715e></span>      testing_env<span style=color:#f92672>!</span>(context);
    };
  }

  <span style=color:#75715e>#[test]</span>
  <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>contract_works</span>() {
    <span style=color:#75715e>// initialize the testing context
</span><span style=color:#75715e></span>    init_context<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;tifrel.testnet&#34;</span>);

    <span style=color:#75715e>// the actual test stays as it was in the plain-rust case
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> contract <span style=color:#f92672>=</span> Contract::default();
    assert_eq!(contract.execute(<span style=color:#ae81ff>4</span>), <span style=color:#ae81ff>4</span>);
    assert_eq!(contract.execute(<span style=color:#ae81ff>2</span>), <span style=color:#ae81ff>6</span>);
  }
}
</code></pre></div><ul>
<li><a href=https://borsh.io/>Borsh</a> is a binary serialization format that allows to
translate between something easily comprehensible, e.g. a <code>struct</code>, an <code>enum</code>,
or a plain <code>i32</code> and something that&rsquo;s efficient to store and transmit, aka
some raw bytes. We need it, because that&rsquo;s how we store data on the NEAR
blockchain.</li>
<li><code>near_sdk::near_bindgen</code> automagically wraps your contract and equips it with
all it needs to a) compile to Wasm and b) interact with other parts of the
NEAR protocol, e.g. other smart contracts or NEAR acconts. All parts of your
smart contract (<code>struct { ... }</code>, <code>impl</code> blocks) need to be wrapped.</li>
</ul>
<p>If all you wanted to do is deploying some logic on-chain, that&rsquo;s already all you
need. But we want to deploy something high-quality. We want to make use of
practices like TDD, so we take the time to understand testing for the
blockchain-world as well: Before contract method calls, we need to initialize a
context.
<a href=https://docs.rs/near-sdk/latest/near_sdk/struct.VMContext.html>The context</a>
holds information like the calling account of a contracts methods, NEAR tokens
attached to the call, or block information. A context will be used for all
subsequent function calls, until it is set again.</p>
<h2 id=writing-tests-for-our-actual-contract>Writing tests for our actual contract<a hidden class=anchor aria-hidden=true href=#writing-tests-for-our-actual-contract>#</a></h2>
<p>Now that we&rsquo;ve gained an understanding of how to write smart contracts on NEAR,
let&rsquo;s start by writing the test for our actual &ldquo;Buy Me A Coffee Contract&rdquo;:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=color:#75715e>#[cfg(test)]</span>
<span style=color:#66d9ef>mod</span> tests {
  <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>super</span>::<span style=color:#f92672>*</span>;
  <span style=color:#66d9ef>use</span> near_sdk::test_utils::VMContextBuilder;
  <span style=color:#66d9ef>use</span> near_sdk::{testing_env, MockedBlockchain};
  <span style=color:#66d9ef>use</span> std::convert::TryInto;

  <span style=color:#75715e>// Handy if you don&#39;t wish to deal with yoctoNEAR all the time
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> ONE_NEAR: <span style=color:#a6e22e>near_sdk</span>::Balance <span style=color:#f92672>=</span> <span style=color:#ae81ff>1_000_000_000_000_000_000_000_000</span>;

  macro_rules! init_context {
    (<span style=color:#75715e>$account</span>:<span style=color:#a6e22e>expr</span>) <span style=color:#f92672>=&gt;</span> {
      <span style=color:#66d9ef>let</span> account <span style=color:#f92672>=</span> <span style=color:#75715e>$account</span>.to_string().try_into().unwrap();

      <span style=color:#66d9ef>let</span> context <span style=color:#f92672>=</span> VMContextBuilder::new()
        .predecessor_account_id(account)
        .build();

      testing_env<span style=color:#f92672>!</span>(context);
    };

    <span style=color:#75715e>// Another macro pattern, as we now need to send some NEAR with our contract
</span><span style=color:#75715e></span>    <span style=color:#75715e>// calls
</span><span style=color:#75715e></span>    (<span style=color:#75715e>$account</span>:<span style=color:#a6e22e>expr</span>, <span style=color:#75715e>$deposit</span>:<span style=color:#a6e22e>expr</span>) <span style=color:#f92672>=&gt;</span> {
      <span style=color:#66d9ef>let</span> account <span style=color:#f92672>=</span> <span style=color:#75715e>$account</span>.to_string().try_into().unwrap();

      <span style=color:#66d9ef>let</span> context <span style=color:#f92672>=</span> VMContextBuilder::new()
        .predecessor_account_id(account)
        .attached_deposit(<span style=color:#75715e>$deposit</span>)
        .build();

      testing_env<span style=color:#f92672>!</span>(context);
    };
  }

  <span style=color:#75715e>#[test]</span>
  <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>contract_works</span>() {
    init_context<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;tifrel.testnet&#34;</span>);

    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> contract <span style=color:#f92672>=</span> BuyMeACoffee::initialize(<span style=color:#e6db74>&#34;tifrel.testnet&#34;</span>.into());
    assert_eq!(contract.top_coffee_buyer(), None);

    <span style=color:#75715e>// our next contract call will be by &#34;lovely-person.testnet&#34;, with one NEAR
</span><span style=color:#75715e></span>    <span style=color:#75715e>// attached to the call
</span><span style=color:#75715e></span>    init_context<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;lovely-person.testnet&#34;</span>, <span style=color:#ae81ff>1</span> <span style=color:#f92672>*</span> ONE_NEAR);
    contract.buy_coffee();
    <span style=color:#75715e>// We can see the donation if we query the contract by `AccountId`
</span><span style=color:#75715e></span>    assert_eq!(
      contract.coffee_near_from(<span style=color:#e6db74>&#34;lovely-person.testnet&#34;</span>.into()),
      <span style=color:#ae81ff>1</span> <span style=color:#f92672>*</span> ONE_NEAR
    );
    <span style=color:#75715e>// Since it&#39;s the first donation, it has taken the leaderboard
</span><span style=color:#75715e></span>    assert_eq!(
      contract.top_coffee_buyer(),
      Some((<span style=color:#e6db74>&#34;lovely-person.testnet&#34;</span>.into(), <span style=color:#ae81ff>1</span> <span style=color:#f92672>*</span> ONE_NEAR))
    );

    <span style=color:#75715e>// Let&#39;s do it again
</span><span style=color:#75715e></span>    init_context<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;another-lovely-person.testnet&#34;</span>, <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> ONE_NEAR);
    contract.buy_coffee();
    assert_eq!(
      contract.coffee_near_from(<span style=color:#e6db74>&#34;another-lovely-person.testnet&#34;</span>.into()),
      <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> ONE_NEAR
    );
    assert_eq!(
      contract.top_coffee_buyer(),
      Some((<span style=color:#e6db74>&#34;another-lovely-person.testnet&#34;</span>.into(), <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> ONE_NEAR))
    );
  }
}
</code></pre></div><p>This test ensures that</p>
<ol>
<li>The contract initializes</li>
<li>NEAR accounts can send NEAR tokens to it</li>
<li>We can query the contract for specific accounts and get their total NEAR
donation</li>
<li>The account that donated the most can be queried. Think of it as a
single-slot hall of fame.</li>
</ol>
<p>What&rsquo;s the best part? Now we can issue <code>cargo test</code>, and actually verify that
what we&rsquo;re building is doing what we want it to. Remember that <code>cargo run</code> on a
library doesn&rsquo;t do anything, and <code>cargo build</code> is shaky ground when you want to
attach (potentially valuable) digital assets to whatever you&rsquo;re building.</p>
<h2 id=wrap-up>Wrap-up<a hidden class=anchor aria-hidden=true href=#wrap-up>#</a></h2>
<p>We have gotten familiar with the basics of smart contracts in Wasm environemnts,
and learned how to set up tests for NEAR smart contracts. The
<a href=../build-on-near-1.2>next post</a> we will TDD ourselves to deployment.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=http://tifrel.github.io/tags/build-on-near/>Build on NEAR</a></li>
<li><a href=http://tifrel.github.io/tags/rust/>Rust</a></li>
<li><a href=http://tifrel.github.io/tags/near-protocol/>NEAR protocol</a></li>
<li><a href=http://tifrel.github.io/tags/smart-contracts/>Smart contracts</a></li>
</ul>
<nav class=paginav>
<a class=prev href=http://tifrel.github.io/posts/build-on-near-1.2/>
<span class=title>« Prev Page</span>
<br>
<span>Build on NEAR: Our first smart contract (part 1.2)</span>
</a>
<a class=next href=http://tifrel.github.io/posts/build-on-near-0/>
<span class=title>Next Page »</span>
<br>
<span>Build on NEAR: Getting started (part 0)</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Build on NEAR: Our first smart contract (part 1.1) on twitter" href="https://twitter.com/intent/tweet/?text=Build%20on%20NEAR%3a%20Our%20first%20smart%20contract%20%28part%201.1%29&url=http%3a%2f%2ftifrel.github.io%2fposts%2fbuild-on-near-1.1%2f&hashtags=BuildonNEAR%2cRust%2cNEARprotocol%2cSmartcontracts"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Build on NEAR: Our first smart contract (part 1.1) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2ftifrel.github.io%2fposts%2fbuild-on-near-1.1%2f&title=Build%20on%20NEAR%3a%20Our%20first%20smart%20contract%20%28part%201.1%29&summary=Build%20on%20NEAR%3a%20Our%20first%20smart%20contract%20%28part%201.1%29&source=http%3a%2f%2ftifrel.github.io%2fposts%2fbuild-on-near-1.1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Build on NEAR: Our first smart contract (part 1.1) on reddit" href="https://reddit.com/submit?url=http%3a%2f%2ftifrel.github.io%2fposts%2fbuild-on-near-1.1%2f&title=Build%20on%20NEAR%3a%20Our%20first%20smart%20contract%20%28part%201.1%29"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Build on NEAR: Our first smart contract (part 1.1) on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2ftifrel.github.io%2fposts%2fbuild-on-near-1.1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Build on NEAR: Our first smart contract (part 1.1) on whatsapp" href="https://api.whatsapp.com/send?text=Build%20on%20NEAR%3a%20Our%20first%20smart%20contract%20%28part%201.1%29%20-%20http%3a%2f%2ftifrel.github.io%2fposts%2fbuild-on-near-1.1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Build on NEAR: Our first smart contract (part 1.1) on telegram" href="https://telegram.me/share/url?text=Build%20on%20NEAR%3a%20Our%20first%20smart%20contract%20%28part%201.1%29&url=http%3a%2f%2ftifrel.github.io%2fposts%2fbuild-on-near-1.1%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=http://tifrel.github.io/>Till's blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>